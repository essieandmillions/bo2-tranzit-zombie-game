<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Call of Duty: Black Ops 2 - Tranzit</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            font-family: 'Arial Black', sans-serif;
            background: #000;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container { width: 100vw; height: 100vh; position: relative; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: #fff; }

        #hud { position: absolute; bottom: 120px; left: 10px; font-size: 16px; background: rgba(0,0,0,0.8); padding: 12px; border-radius: 5px; border: 2px solid #666; }
        #info { position: absolute; top: 10px; right: 10px; font-size: 14px; background: rgba(0,0,0,0.8); padding: 12px; border-radius: 5px; border: 2px solid #666; text-align: right; }

        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
        #crosshair::before { width: 3px; height: 30px; left: 13.5px; }
        #crosshair::after { width: 30px; height: 3px; top: 13.5px; }

        #mobile-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 200px; pointer-events: all; }
        #joystick { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; background: rgba(255,255,255,0.15); border: 3px solid rgba(255,255,255,0.4); border-radius: 50%; }
        #joystick-inner { position: absolute; width: 60px; height: 60px; background: rgba(255,255,255,0.6); border-radius: 50%; left: 40px; top: 40px; border: 2px solid #fff; }

        #shoot-btn { position: absolute; bottom: 50px; right: 40px; width: 90px; height: 90px; background: rgba(200,0,0,0.6); border: 4px solid rgba(255,0,0,0.9); border-radius: 50%; font-size: 28px; color: #fff; display: flex; align-items: center; justify-content: center; pointer-events: all; font-weight: bold; }
        #reload-btn { position: absolute; bottom: 50px; right: 150px; width: 70px; height: 70px; background: rgba(0,100,200,0.6); border: 3px solid rgba(0,150,255,0.9); border-radius: 50%; font-size: 16px; color: #fff; display: flex; align-items: center; justify-content: center; pointer-events: all; font-weight: bold; }
        #repair-btn { position: absolute; bottom: 140px; right: 90px; width: 70px; height: 70px; background: rgba(200,150,0,0.6); border: 3px solid rgba(255,200,0,0.9); border-radius: 50%; font-size: 12px; color: #fff; display: none; align-items: center; justify-content: center; pointer-events: all; font-weight: bold; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; pointer-events: all; }
        #start-screen h1 { font-size: 28px; color: #ff6600; margin-bottom: 10px; text-align: center; padding: 0 20px; text-shadow: 3px 3px 6px #000; }
        #start-screen h2 { font-size: 36px; color: #fff; margin-bottom: 30px; text-shadow: 2px 2px 4px #000; }
        #start-screen button { font-size: 22px; padding: 15px 50px; background: #ff6600; color: #000; border: none; border-radius: 5px; font-weight: bold; }
        .info-text { font-size: 11px; color: #aaa; margin-top: 25px; text-align: center; padding: 0 20px; line-height: 1.8; }

        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; pointer-events: all; }
        #game-over h1 { font-size: 48px; color: #f00; margin-bottom: 20px; text-shadow: 3px 3px 8px #000; }
        #game-over p { font-size: 20px; color: #fff; margin: 10px 0; }
        #game-over button { font-size: 20px; padding: 12px 40px; background: #ff6600; color: #000; border: none; border-radius: 5px; margin-top: 20px; font-weight: bold; }

        #repair-prompt { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; background: rgba(255,200,0,0.9); color: #000; padding: 15px 25px; border-radius: 5px; display: none; font-weight: bold; pointer-events: none; border: 3px solid #ff6600; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1>CALL OF DUTY: BLACK OPS II</h1>
            <h2>TRANZIT</h2>
            <button id="start-btn">START GAME</button>
            <div class="info-text">
                <p>Left joystick: Move | Swipe: Look around</p>
                <p>Red button: Shoot | Blue button: Reload</p>
                <p>Repair windows when zombies break through</p>
                <p>Survive the undead horde!</p>
            </div>
        </div>

        <div id="game-over">
            <h1>GAME OVER</h1>
            <p id="final-round">Round: 0</p>
            <p id="final-kills">Kills: 0</p>
            <button id="restart-btn">RESTART</button>
        </div>

        <div id="ui-overlay">
            <div id="info">
                <div style="color: #ff6600; font-size: 18px; font-weight: bold;">ROUND <span id="round">1</span></div>
                <div style="margin-top: 5px;">Zombies: <span id="zombies-left">0</span></div>
                <div style="margin-top: 5px; color: #ffaa00;">Kills: <span id="total-kills">0</span></div>
            </div>
            <div id="hud">
                <div style="color: #ff0000; font-size: 20px; font-weight: bold;">HP: <span id="health">100</span></div>
                <div style="color: #ffaa00; margin-top: 5px; font-size: 18px;">Points: <span id="points">500</span></div>
                <div style="margin-top: 8px; border-top: 1px solid #666; padding-top: 5px;">
                    <div style="font-size: 16px;"><span id="weapon-name">M1911</span></div>
                    <div style="font-size: 18px; font-weight: bold;"><span id="ammo">8</span> / <span id="reserve-ammo">32</span></div>
                </div>
            </div>
            <div id="crosshair"></div>
            <div id="repair-prompt">Hold to Repair Window [10 Points]</div>
        </div>

        <div id="mobile-controls">
            <div id="joystick">
                <div id="joystick-inner"></div>
            </div>
            <button id="shoot-btn">ðŸ”«</button>
            <button id="reload-btn">R</button>
            <button id="repair-btn">FIX</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const gameState = {
            player: {
                health: 100,
                maxHealth: 100,
                points: 500,
                currentWeapon: 0,
                weapons: [{
                    name: 'M1911',
                    damage: 50,
                    ammo: 8,
                    reserve: 32,
                    fireRate: 250,
                    maxAmmo: 8,
                    maxReserve: 32
                }],
                position: { x: 0, y: 1.6, z: 0 },
                velocity: { x: 0, y: 0, z: 0 }
            },
            round: 1,
            zombiesKilled: 0,
            totalKills: 0,
            zombiesInRound: 6,
            zombiesSpawned: 0,
            gameStarted: false,
            gameover: false,
            lastShot: 0,
            reloading: false,
            repairingWindow: null,
            repairStartTime: 0
        };

        let scene, camera, renderer, zombies = [], windows = [];
        const clock = new THREE.Clock();
        let joystickActive = false, joystickVector = { x: 0, y: 0 };
        let touchStartX = 0, touchStartY = 0, cameraRotation = { x: 0, y: 0 };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1510, 20, 120);
            scene.background = new THREE.Color(0x0d0a08);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 1.6, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

            // Realistic lighting
            const ambientLight = new THREE.AmbientLight(0x302520, 0.3);
            scene.add(ambientLight);

            const moonLight = new THREE.DirectionalLight(0x6688aa, 0.4);
            moonLight.position.set(50, 100, 30);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);

            // Fog lights around the building
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const light = new THREE.PointLight(0xff6600, 0.8, 30);
                light.position.set(Math.cos(angle) * 15, 3, Math.sin(angle) * 15);
                scene.add(light);
            }

            createRealisticWorld();
            createWindows();
            setupMobileControls();

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            window.addEventListener('resize', onWindowResize);
        }

        function createRealisticWorld() {
            // Detailed ground with texture
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a2f28,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;

            // Add terrain variation
            for (let i = 0; i < groundGeometry.vertices.length; i++) {
                groundGeometry.vertices[i].z = Math.random() * 0.3;
            }
            groundGeometry.computeVertexNormals();
            scene.add(ground);

            // Bus Depot Building - detailed structure
            const buildingGroup = new THREE.Group();

            // Main building walls
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a3f38,
                roughness: 0.8,
                metalness: 0.2
            });

            // Front wall
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(30, 8, 0.5), wallMaterial);
            frontWall.position.set(0, 4, -15);
            frontWall.castShadow = true;
            buildingGroup.add(frontWall);

            // Back wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(30, 8, 0.5), wallMaterial);
            backWall.position.set(0, 4, 15);
            backWall.castShadow = true;
            buildingGroup.add(backWall);

            // Left wall
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 30), wallMaterial);
            leftWall.position.set(-15, 4, 0);
            leftWall.castShadow = true;
            buildingGroup.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 30), wallMaterial);
            rightWall.position.set(15, 4, 0);
            rightWall.castShadow = true;
            buildingGroup.add(rightWall);

            // Roof
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f1a, roughness: 0.9 });
            const roof = new THREE.Mesh(new THREE.BoxGeometry(31, 0.5, 31), roofMaterial);
            roof.position.set(0, 8, 0);
            roof.castShadow = true;
            buildingGroup.add(roof);

            // Interior floor
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x3d3329, roughness: 0.7 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(29, 29), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.1;
            floor.receiveShadow = true;
            buildingGroup.add(floor);

            // Add debris and details
            for (let i = 0; i < 12; i++) {
                const debrisSize = 0.5 + Math.random() * 1;
                const debris = new THREE.Mesh(
                    new THREE.BoxGeometry(debrisSize, debrisSize, debrisSize),
                    new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.9 })
                );
                debris.position.set(
                    (Math.random() - 0.5) * 25,
                    debrisSize / 2,
                    (Math.random() - 0.5) * 25
                );
                debris.rotation.set(Math.random(), Math.random(), Math.random());
                debris.castShadow = true;
                buildingGroup.add(debris);
            }

            // Mystery Box
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                emissive: 0x442200,
                emissiveIntensity: 0.3,
                metalness: 0.5,
                roughness: 0.5
            });
            const mysteryBox = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), boxMaterial);
            mysteryBox.position.set(-10, 0.75, -10);
            mysteryBox.castShadow = true;

            // Box glow
            const boxLight = new THREE.PointLight(0xffaa00, 1, 5);
            boxLight.position.copy(mysteryBox.position);
            boxLight.position.y += 1;
            scene.add(boxLight);
            buildingGroup.add(mysteryBox);

            scene.add(buildingGroup);

            // Outside elements
            // Broken fence
            for (let i = 0; i < 8; i++) {
                const fencePost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
                );
                fencePost.position.set(i * 3 - 12, 1, -25);
                fencePost.rotation.z = (Math.random() - 0.5) * 0.3;
                fencePost.castShadow = true;
                scene.add(fencePost);
            }
        }

        function createWindows() {
            // Window positions around the building
            const windowPositions = [
                { x: -10, z: -14.8, rot: 0 },
                { x: 0, z: -14.8, rot: 0 },
                { x: 10, z: -14.8, rot: 0 },
                { x: -10, z: 14.8, rot: Math.PI },
                { x: 0, z: 14.8, rot: Math.PI },
                { x: 10, z: 14.8, rot: Math.PI },
            ];

            windowPositions.forEach(pos => {
                const windowData = {
                    position: pos,
                    boards: [],
                    health: 6,
                    maxHealth: 6,
                    zombiesWaiting: [],
                    breakingZombie: null
                };

                // Window frame
                const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1a0a });
                const frame = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.3), frameMaterial);
                frame.position.set(pos.x, 2.5, pos.z);
                frame.rotation.y = pos.rot;
                scene.add(frame);
                windowData.frame = frame;

                // Window boards
                for (let i = 0; i < 6; i++) {
                    const boardMaterial = new THREE.MeshStandardMaterial({
                        color: 0x4a3a2a,
                        roughness: 0.8
                    });
                    const board = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.4, 0.2), boardMaterial);
                    board.position.set(pos.x, 1 + i * 0.45, pos.z);
                    board.rotation.y = pos.rot;
                    board.visible = true;
                    scene.add(board);
                    windowData.boards.push(board);
                }

                windows.push(windowData);
            });
        }

        function spawnZombie() {
            if (gameState.zombiesSpawned >= gameState.zombiesInRound) return;

            // Pick random window
            const windowData = windows[Math.floor(Math.random() * windows.length)];

            // Realistic zombie model
            const zombieGroup = new THREE.Group();

            // Body
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x556655,
                roughness: 0.9,
                metalness: 0.1
            });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.35, 1.2, 8), bodyMaterial);
            body.position.y = 0.6;
            zombieGroup.add(body);

            // Head
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x667755 });
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), headMaterial);
            head.position.y = 1.5;
            zombieGroup.add(head);

            // Eyes (glowing)
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMaterial);
            leftEye.position.set(-0.1, 1.55, 0.21);
            zombieGroup.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMaterial);
            rightEye.position.set(0.1, 1.55, 0.21);
            zombieGroup.add(rightEye);

            // Arms
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x556655 });
            const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.8, 6), armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.rotation.z = 0.3;
            zombieGroup.add(leftArm);
            const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.8, 6), armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.rotation.z = -0.3;
            zombieGroup.add(rightArm);

            // Legs
            const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.6, 6), armMaterial);
            leftLeg.position.set(-0.2, 0, 0);
            zombieGroup.add(leftLeg);
            const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.6, 6), armMaterial);
            rightLeg.position.set(0.2, 0, 0);
            zombieGroup.add(rightLeg);

            // Position at window
            const spawnOffset = Math.random() * 2 - 1;
            zombieGroup.position.set(
                windowData.position.x + spawnOffset,
                1,
                windowData.position.z + (windowData.position.z > 0 ? 3 : -3)
            );

            zombieGroup.userData = {
                health: 150 + (gameState.round - 1) * 100,
                maxHealth: 150 + (gameState.round - 1) * 100,
                speed: 0.8 + gameState.round * 0.05,
                damage: 15 + gameState.round * 3,
                state: 'window', // window, entering, roaming, attacking
                targetWindow: windowData,
                animTime: 0,
                bodyParts: { body, head, leftArm, rightArm, leftLeg, rightLeg }
            };

            scene.add(zombieGroup);
            zombies.push(zombieGroup);
            gameState.zombiesSpawned++;

            windowData.zombiesWaiting.push(zombieGroup);
            if (!windowData.breakingZombie) {
                windowData.breakingZombie = zombieGroup;
            }
        }

        function updateWindows(delta) {
            windows.forEach(windowData => {
                if (windowData.breakingZombie && windowData.health > 0) {
                    // Zombie breaking window
                    if (Math.random() < 0.02) {
                        windowData.health--;
                        if (windowData.health >= 0 && windowData.health < windowData.boards.length) {
                            windowData.boards[windowData.health].visible = false;
                        }

                        if (windowData.health <= 0) {
                            // Zombie enters
                            const zombie = windowData.breakingZombie;
                            zombie.userData.state = 'entering';
                            windowData.zombiesWaiting = windowData.zombiesWaiting.filter(z => z !== zombie);
                            windowData.breakingZombie = windowData.zombiesWaiting[0] || null;
                        }
                    }
                }

                // Check if player near window for repair
                const distToWindow = Math.sqrt(
                    Math.pow(camera.position.x - windowData.position.x, 2) +
                    Math.pow(camera.position.z - windowData.position.z, 2)
                );

                if (distToWindow < 4 && windowData.health < windowData.maxHealth) {
                    document.getElementById('repair-prompt').style.display = 'block';
                    document.getElementById('repair-btn').style.display = 'flex';
                } else if (gameState.repairingWindow === windowData) {
                    document.getElementById('repair-prompt').style.display = 'none';
                    document.getElementById('repair-btn').style.display = 'none';
                    gameState.repairingWindow = null;
                }
            });
        }

        function repairWindow() {
            // Find closest window
            let closestWindow = null;
            let closestDist = 4;

            windows.forEach(windowData => {
                const dist = Math.sqrt(
                    Math.pow(camera.position.x - windowData.position.x, 2) +
                    Math.pow(camera.position.z - windowData.position.z, 2)
                );
                if (dist < closestDist && windowData.health < windowData.maxHealth) {
                    closestDist = dist;
                    closestWindow = windowData;
                }
            });

            if (closestWindow && gameState.player.points >= 10) {
                gameState.player.points -= 10;
                closestWindow.health++;
                if (closestWindow.health <= closestWindow.boards.length) {
                    closestWindow.boards[closestWindow.health - 1].visible = true;
                }
                updateUI();
            }
        }

        function updateZombies(delta) {
            zombies.forEach(zombie => {
                const userData = zombie.userData;
                userData.animTime += delta;

                // Animation
                const { body, leftArm, rightArm, leftLeg, rightLeg } = userData.bodyParts;
                const walkCycle = Math.sin(userData.animTime * 3) * 0.3;
                leftArm.rotation.x = walkCycle;
                rightArm.rotation.x = -walkCycle;
                leftLeg.rotation.x = -walkCycle;
                rightLeg.rotation.x = walkCycle;
                body.rotation.z = Math.sin(userData.animTime * 2) * 0.1;

                if (userData.state === 'window') {
                    // Waiting at window
                    zombie.lookAt(new THREE.Vector3(camera.position.x, zombie.position.y, camera.position.z));

                } else if (userData.state === 'entering') {
                    // Moving through window
                    const windowPos = userData.targetWindow.position;
                    const targetPos = new THREE.Vector3(
                        windowPos.x,
                        zombie.position.y,
                        windowPos.z + (windowPos.z > 0 ? -2 : 2)
                    );

                    const dir = new THREE.Vector3();
                    dir.subVectors(targetPos, zombie.position);
                    if (dir.length() < 0.5) {
                        userData.state = 'roaming';
                    } else {
                        dir.normalize();
                        zombie.position.add(dir.multiplyScalar(userData.speed * delta));
                    }

                } else if (userData.state === 'roaming') {
                    // Chase player
                    const dir = new THREE.Vector3();
                    dir.subVectors(camera.position, zombie.position);
                    dir.y = 0;

                    const dist = dir.length();
                    if (dist < 1.5) {
                        userData.state = 'attacking';
                    } else {
                        dir.normalize();
                        zombie.position.add(dir.multiplyScalar(userData.speed * delta));
                        zombie.lookAt(new THREE.Vector3(camera.position.x, zombie.position.y, camera.position.z));
                    }

                } else if (userData.state === 'attacking') {
                    const dist = zombie.position.distanceTo(camera.position);
                    if (dist > 2) {
                        userData.state = 'roaming';
                    } else {
                        // Attack player
                        if (Math.random() < 0.03) {
                            gameState.player.health -= userData.damage;
                            if (gameState.player.health <= 0) {
                                gameOver();
                            }
                            updateUI();
                        }
                    }
                }
            });

            // Spawn more zombies
            if (gameState.zombiesSpawned < gameState.zombiesInRound && zombies.length < 24) {
                if (Math.random() < 0.015) {
                    spawnZombie();
                }
            }
        }

        function setupMobileControls() {
            const joystick = document.getElementById('joystick');
            const joystickInner = document.getElementById('joystick-inner');

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
            });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);
                joystickVector.x = Math.cos(angle) * (distance / 40);
                joystickVector.y = Math.sin(angle) * (distance / 40);
                joystickInner.style.left = (40 + Math.cos(angle) * distance) + 'px';
                joystickInner.style.top = (40 + Math.sin(angle) * distance) + 'px';
            });

            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickVector.x = 0;
                joystickVector.y = 0;
                joystickInner.style.left = '40px';
                joystickInner.style.top = '40px';
            });

            document.getElementById('shoot-btn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });

            document.getElementById('reload-btn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                reload();
            });

            document.getElementById('repair-btn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                repairWindow();
            });

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.target === renderer.domElement) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.target === renderer.domElement && gameState.gameStarted) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;
                    cameraRotation.y -= deltaX * 0.003;
                    cameraRotation.x -= deltaY * 0.003;
                    cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.gameStarted = true;
            gameState.gameover = false;
            spawnZombie();
            spawnZombie();
            animate();
        }

        function restartGame() {
            // Clear zombies
            zombies.forEach(z => scene.remove(z));
            zombies = [];

            // Reset windows
            windows.forEach(w => {
                w.health = w.maxHealth;
                w.zombiesWaiting = [];
                w.breakingZombie = null;
                w.boards.forEach(b => b.visible = true);
            });

            // Reset game state
            gameState.player.health = 100;
            gameState.player.points = 500;
            gameState.player.currentWeapon = 0;
            gameState.player.weapons = [{
                name: 'M1911',
                damage: 50,
                ammo: 8,
                reserve: 32,
                fireRate: 250,
                maxAmmo: 8,
                maxReserve: 32
            }];
            gameState.round = 1;
            gameState.zombiesKilled = 0;
            gameState.totalKills = 0;
            gameState.zombiesInRound = 6;
            gameState.zombiesSpawned = 0;
            gameState.gameover = false;

            camera.position.set(0, 1.6, 5);
            cameraRotation = { x: 0, y: 0 };

            document.getElementById('game-over').style.display = 'none';
            updateUI();
            startGame();
        }

        function shoot() {
            const now = Date.now();
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            if (gameState.reloading || now - gameState.lastShot < weapon.fireRate || weapon.ammo <= 0) return;

            gameState.lastShot = now;
            weapon.ammo--;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(zombies, true);

            if (intersects.length > 0) {
                let hitZombie = intersects[0].object;
                while (hitZombie.parent && !hitZombie.userData.health) {
                    hitZombie = hitZombie.parent;
                }

                if (hitZombie.userData.health) {
                    hitZombie.userData.health -= weapon.damage;

                    // Hit effect
                    hitZombie.children.forEach(child => {
                        if (child.material) {
                            const originalEmissive = child.material.emissive.clone();
                            child.material.emissive = new THREE.Color(0xff0000);
                            setTimeout(() => {
                                child.material.emissive = originalEmissive;
                            }, 100);
                        }
                    });

                    if (hitZombie.userData.health <= 0) {
                        scene.remove(hitZombie);
                        zombies = zombies.filter(z => z !== hitZombie);
                        gameState.zombiesKilled++;
                        gameState.totalKills++;
                        gameState.player.points += 100;

                        // Remove from window queue
                        windows.forEach(w => {
                            w.zombiesWaiting = w.zombiesWaiting.filter(z => z !== hitZombie);
                            if (w.breakingZombie === hitZombie) {
                                w.breakingZombie = w.zombiesWaiting[0] || null;
                            }
                        });

                        if (gameState.zombiesKilled >= gameState.zombiesInRound) {
                            nextRound();
                        }
                    }
                }
            }

            // Muzzle flash
            const flash = new THREE.PointLight(0xffff00, 3, 3);
            flash.position.copy(camera.position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);

            updateUI();
        }

        function reload() {
            if (gameState.reloading) return;
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            if (weapon.ammo >= weapon.maxAmmo || weapon.reserve <= 0) return;

            gameState.reloading = true;
            setTimeout(() => {
                const needed = weapon.maxAmmo - weapon.ammo;
                const available = Math.min(needed, weapon.reserve);
                weapon.ammo += available;
                weapon.reserve -= available;
                gameState.reloading = false;
                updateUI();
            }, 2000);
        }

        function nextRound() {
            gameState.round++;
            gameState.zombiesKilled = 0;
            gameState.zombiesInRound = Math.floor(6 * Math.pow(1.12, gameState.round - 1));
            gameState.zombiesSpawned = 0;
            gameState.player.points += 500;
            updateUI();
        }

        function gameOver() {
            gameState.gameover = true;
            gameState.gameStarted = false;
            gameState.player.health = 0;
            document.getElementById('final-round').textContent = 'Round: ' + gameState.round;
            document.getElementById('final-kills').textContent = 'Kills: ' + gameState.totalKills;
            document.getElementById('game-over').style.display = 'flex';
        }

        function updatePlayer(delta) {
            if (gameState.gameover) return;

            const speed = 4 * delta;
            const direction = new THREE.Vector3(-joystickVector.x, 0, joystickVector.y);

            if (direction.length() > 0) {
                direction.normalize();
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                const move = new THREE.Vector3();
                move.addScaledVector(forward, -direction.z);
                move.addScaledVector(right, -direction.x);

                const newPos = camera.position.clone().add(move.multiplyScalar(speed));

                // Collision with walls
                if (Math.abs(newPos.x) < 14 && Math.abs(newPos.z) < 14) {
                    camera.position.copy(newPos);
                }
            }

            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;
        }

        function updateUI() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health));
            document.getElementById('points').textContent = gameState.player.points;
            document.getElementById('weapon-name').textContent = weapon.name;
            document.getElementById('ammo').textContent = weapon.ammo;
            document.getElementById('reserve-ammo').textContent = weapon.reserve;
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('zombies-left').textContent = gameState.zombiesInRound - gameState.zombiesKilled;
            document.getElementById('total-kills').textContent = gameState.totalKills;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            if (!gameState.gameStarted || gameState.gameover) return;
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            updatePlayer(delta);
            updateZombies(delta);
            updateWindows(delta);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>